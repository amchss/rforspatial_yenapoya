{
  "hash": "68b6984a90272d514e18b0fbb4e6f826",
  "result": {
    "engine": "knitr",
    "markdown": "---\nembed-resources: true\n---\n\n\n\n\n# Spatial Data Manipulation\n\n:::{style=\"text-align:justify\"}\n\nIt is expected that by end of the session, students will be able to understand as well as apply varied methods for manipulation of spatial datasets.\n\n:::\n\n## Importing spatial data as `sf` object into R.\n\n### Why importing as sf object is recommended?\n\n:::{style=\"text-align:justify\"}\n\nSimple features are open standard objects which have been endorsed by Open Geospatial Consortium. They represent heirarchial data model for 17 geometry types.\n\nDuring this session and in subsequent session on Spatial Epidemiology, we shall be using `sf` package. This is because *sf* package has inbuilt capabilities of handling 7 most common data models of simple features. Further,R spatial ecosystem is more efficient with use of *sf* package compared to previous packages.\n\nShapefile format data can be imported into the R ecosystem using `st_read()` or `read_sf()` function. Both are similar in function with subtle differences. `read_sf()` chooses a few tidyverse defaults such as silent (`st_read()` gives a short report), returns a spatial tibble (`st_read()` returns a `dataframe`), doesnot convert strings to factors (`st_read()` converts to factors by default) and accepts list columns as input. For other formats `st_as_sf()` contains a family of conversion functions.\n\n:::\n\n## Understanding and Tranformation of Coordinated Reference System (CRS).\n\n### Know the CRS\n\n:::{style=\"text-align:justify\"}\n\nTo know the crs of a spatial dataset, use `sf::st_crs()` function.\n\n:::\n\n### Transforming CRS of Spatial Data\n\n:::{style=\"text-align:justify\"}\n\nWhen we have two or more related spatial datasets, and the CRS are different, we can transform the CRS using `sf::st_transform()` function.\n\n:::\n\n### Loading datasets\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Install packages. We need to install packages only once in the system.\n#install.packages(\"sf\")\n#install.packages(\"tidyverse\")\n#Load library. We need to load library everytime to use the functions\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLinking to GEOS 3.11.2, GDAL 3.8.2, PROJ 9.3.1; sf_use_s2() is TRUE\n```\n\n\n:::\n:::\n\n\n\n\n### World map.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld <- read_rds(here::here(\"data\", \"world_india_compliant.rds\"))\n\nst_crs(world)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n```\n\n\n:::\n:::\n\n\n\n\n### India map with state boundaries.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindia <- read_rds(here::here( \"data\", \"india_states.rds\"))\n\nindia <- india |> \n  janitor::clean_names()\n\nst_crs(india)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: WGS 84 / Pseudo-Mercator \n  wkt:\nPROJCRS[\"WGS 84 / Pseudo-Mercator\",\n    BASEGEOGCRS[\"WGS 84\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"Popular Visualisation Pseudo-Mercator\",\n        METHOD[\"Popular Visualisation Pseudo Mercator\",\n            ID[\"EPSG\",1024]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"False easting\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"unknown\"],\n        AREA[\"World - 85Â°S to 85Â°N\"],\n        BBOX[-85.06,-180,85.06,180]],\n    ID[\"EPSG\",3857]]\n```\n\n\n:::\n\n```{.r .cell-code}\n# Transform to Geog CRS as that of world map\n\nindia <- st_transform(india, crs = 4326)\n```\n:::\n\n\n\n\n### Kerala map with panchayat boundaries.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkerala <- read_rds(here::here(\"data\",\"ker_panchayats.rds\"))\n\n# Clean names\n\nkerala <- kerala |> \n  janitor::clean_names()\n\n# Check CRS\nst_crs(kerala)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"unknown\"],\n        AREA[\"World\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n```\n\n\n:::\n:::\n\n\n\n\n### Anonymised Dengue occurence point data from Trivandrum District.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reading RDS\ndf <- read_rds(here::here( \"data\", \"dengue_sample.rds\"))\n\n# Cleaning names \ndf <- df |> \n  janitor::clean_names()\n\n# Converting as sf object\ndf <- st_as_sf(df, coords = c(\"longitude\", \"latitude\"), crs = 4326)\n```\n:::\n\n\n\n\n## Manipulating Spatial Data based on their location and shape.\n\n### Subset Spatial data based on attributes.\n\n:::{style=\"text-align:justify\"}\n\nThe process of selecting only those locations which have a specified attribute is known as sub-setting and the output is subset. It is done to understand spatial distribution of a given variable and thus identify underlying patterns. `sf` objects have inherent dataframe class. Hence, `tidyverse::filter()` function can be used for obtaining spatial subsets.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: Subset district from Kerala map whose name is Thiruvananthapuram\n\ntvm <- kerala %>% \n  filter(district == \"Thiruvananthapuram\")\n\n#Overview\ntvm %>% \n  ggplot()+\n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](spatial_data_mani_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n### Spatial relationships based on Topology\n\n:::{style=\"text-align:justify\"}\n\nTopology is defined as spatial relationship between the objects. These include relationships such as common boundaries, intersections, one within the other, crossings, disjunctions, etc.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To identify block from which cases have been reported: \n#It will include all cases which are within as well as \n#on the boundary of a polygon.\n\n(list <- st_intersects(df, tvm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSparse geometry binary predicate list of length 250, where the\npredicate was `intersects'\nfirst 10 elements:\n 1: 64\n 2: 52\n 3: 68\n 4: 52\n 5: 64\n 6: 57\n 7: 53\n 8: 52\n 9: 52\n 10: 52\n```\n\n\n:::\n:::\n\n\n\n\nSimilarly, `st_within()` is used to find the relationship for those strictly within boundaries, `st_disjoint(`) is opposite of `st_intersect()`, `st_touches()` is for those objects which are touching each other (eg. polygons) and `st_within_distance()` for the objects within a buffer distance from the said object.\n\n:::\n\n### Spatial overlay/ joins\n\n:::{style=\"text-align:justify\"}\n\nPresence of a unique key is pre-requisite to joining of datasets. The same concept is utilised for overlay or joining of two or more spatial datasets with location coordinates as unique key. `st_join()` performs spatial joins using location coordinates as unique key. By default, left join is undertaken. in is performed.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 250  19\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"hash_short\"       \"age\"              \"sex1\"             \"day\"             \n [5] \"month\"            \"year\"             \"date\"             \"panchayat_code\"  \n [9] \"population\"       \"dengue\"           \"month2\"           \"dengue1\"         \n[13] \"join_count_n_9_0\" \"area\"             \"aream2\"           \"popden\"          \n[17] \"dengpop\"          \"dengpopdens\"      \"geometry\"        \n```\n\n\n:::\n\n```{.r .cell-code}\ndim(tvm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 83 46\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(tvm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"join_count\"   \"area\"         \"code\"         \"panchayat\"    \"block\"       \n [6] \"municipal\"    \"corporate\"    \"district\"     \"location\"     \"state_id\"    \n[11] \"district_id\"  \"hospital_id\"  \"nameof_hos\"   \"typeof_hos\"   \"place_name\"  \n[16] \"d\"            \"m\"            \"s\"            \"x\"            \"d1\"          \n[21] \"m1\"           \"s1\"           \"y\"            \"postoffice\"   \"ho_sattach\"  \n[26] \"pincode\"      \"lo_body_name\" \"lo_body_type\" \"phone_no\"     \"bed_count\"   \n[31] \"timing\"       \"ambu_servi\"   \"cr_savailab\"  \"cr_snameadd\"  \"ho_stiming\"  \n[36] \"doctors\"      \"nurses\"       \"paramedics\"   \"ambient_ser\"  \"waste_dispo\" \n[41] \"facility\"     \"service\"      \"depart_name\"  \"no_of_asha\"   \"no_of_jphn\"  \n[46] \"geometry\"    \n```\n\n\n:::\n\n```{.r .cell-code}\njoined <- st_join(df, tvm)\n\ndim(joined)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 250  64\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(joined)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"hash_short\"       \"age\"              \"sex1\"             \"day\"             \n [5] \"month\"            \"year\"             \"date\"             \"panchayat_code\"  \n [9] \"population\"       \"dengue\"           \"month2\"           \"dengue1\"         \n[13] \"join_count_n_9_0\" \"area.x\"           \"aream2\"           \"popden\"          \n[17] \"dengpop\"          \"dengpopdens\"      \"geometry\"         \"join_count\"      \n[21] \"area.y\"           \"code\"             \"panchayat\"        \"block\"           \n[25] \"municipal\"        \"corporate\"        \"district\"         \"location\"        \n[29] \"state_id\"         \"district_id\"      \"hospital_id\"      \"nameof_hos\"      \n[33] \"typeof_hos\"       \"place_name\"       \"d\"                \"m\"               \n[37] \"s\"                \"x\"                \"d1\"               \"m1\"              \n[41] \"s1\"               \"y\"                \"postoffice\"       \"ho_sattach\"      \n[45] \"pincode\"          \"lo_body_name\"     \"lo_body_type\"     \"phone_no\"        \n[49] \"bed_count\"        \"timing\"           \"ambu_servi\"       \"cr_savailab\"     \n[53] \"cr_snameadd\"      \"ho_stiming\"       \"doctors\"          \"nurses\"          \n[57] \"paramedics\"       \"ambient_ser\"      \"waste_dispo\"      \"facility\"        \n[61] \"service\"          \"depart_name\"      \"no_of_asha\"       \"no_of_jphn\"      \n```\n\n\n:::\n\n```{.r .cell-code}\njoined %>% ggplot()+\n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](spatial_data_mani_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n### Obtaining aggregated spatial data\n\n:::{style=\"text-align:justify\"}\n\nAggregation of spatial data is a process of condensing the dataset to obtain stratified summary measures.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: To get list of number of cases from each block\njoined %>% \n  group_by(block) %>% \n  summarise(cases = sum(dengue))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 13 features and 2 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 76.71811 ymin: 8.331344 xmax: 77.19514 ymax: 8.811173\nGeodetic CRS:  WGS 84\n# A tibble: 13 × 3\n   block          cases                                                 geometry\n   <chr>          <dbl>                                           <GEOMETRY [°]>\n 1 Athiyannoor        7 MULTIPOINT ((76.97908 8.400357), (76.97289 8.412542), (…\n 2 Chirayinkeezhu     2    MULTIPOINT ((76.78766 8.689444), (76.78253 8.657362))\n 3 Kazhakkoottam     13 MULTIPOINT ((76.81978 8.603385), (76.92593 8.573853), (…\n 4 Kilimanoor         2    MULTIPOINT ((76.87685 8.766624), (76.82115 8.811173))\n 5 Nedumangadu       11 MULTIPOINT ((77.02653 8.549563), (77.0238 8.549926), (7…\n 6 Nemom             38 MULTIPOINT ((76.98578 8.422667), (77.0061 8.439469), (7…\n 7 Parasala           1                                POINT (77.08794 8.331344)\n 8 Perumkadavila      5 MULTIPOINT ((77.19514 8.453647), (77.15896 8.461809), (…\n 9 T. Rural Block     7 MULTIPOINT ((76.96103 8.556535), (76.96095 8.555607), (…\n10 Vamanapuram        1                                POINT (76.92178 8.677913)\n11 Varkala            1                                 POINT (76.8104 8.732897)\n12 Vellanadu         19 MULTIPOINT ((77.07907 8.502114), (77.07872 8.507087), (…\n13 <NA>             143 MULTIPOINT ((76.96146 8.426247), (76.9614 8.426524), (7…\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n### Area calculations.\n\n\nTo determine area of a polygon, `st_area()` function is used.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Example\ntvm %>% \n  filter(panchayat == \"Pallickal\") %>% \n  st_area()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n17038202 [m^2]\n```\n\n\n:::\n:::\n\n\n\n\n## Geometry based functions.\n\n:::{style=\"text-align:justify\"}\n\nWe can transform geometries with uniary and binary transformations. Uniary transformations are based on a single geometry in isolation and includes measures such as creation of buffers and centroids. Binary operations modify the shape of one geometry based on the other and includes measures such as clipping and geometry unions.\n\n:::\n\n### Centroid creation.\n\n:::{style=\"text-align:justify\"}\n\nThe centroid based processes identify the center of a `sf` object and is similar to measure of central tendency. There are many variations in ways to define centre of an `sf` object, however, use of geographical centre remains most common. `st_centroid()` provides centroid values.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npolygon_tvm <- tvm %>% \n  ggplot()+\n  geom_sf()+\n  labs(title = \"Map\")\n\npoint_tvm <- st_centroid(tvm) %>%  \n  ggplot()+\n  geom_sf()+\n  labs(title = \"Centroids\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n\n\n:::\n\n```{.r .cell-code}\nggpubr::ggarrange(polygon_tvm, point_tvm)\n```\n\n::: {.cell-output-display}\n![](spatial_data_mani_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n### Adding centroids to the dataset.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntvm <- cbind(tvm, st_coordinates(st_centroid(tvm)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n\n\n:::\n:::\n\n\n\n\n### Buffer creation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data = tvm %>% \n  filter(panchayat == \"Pallickal\") %>% \n  st_centroid() %>% \n  st_buffer(dist = 5000) )+\n  geom_sf(data = df)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](spatial_data_mani_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\n## Saving Spatial Data and its output.\n\n:::{style=\"text-align:justify\"}\n\nThough `st_write()` function helps in saving spatial datasets as shapefiles, it is recommended that RDS data format be used as it uses less space in the system and is computationally faster to load subsequently.\n\n:::\n## Methods for spatial data manipulation of Raster datasets.\n\n### CRS\n\n:::{style=\"text-align:justify\"}\n\nTo know as well as to set CRS of a raster data, `raster::projections()` function is used. The further difference as compared to vector data is that CRS has to be provided in proj4 definition format for the raster datasets. It does not accept CRS input in espg format.\n\n:::\n\n### Resolution\n\n:::{style=\"text-align:justify\"}\n\nSimilar to area calculations in a vector dataset, we would like to know about the resolution of the raster data. The `res()` function provides dimensions of each of the cell of the raster grid in metres (By default, UTM projection is in metres).\n\n:::\n\n### Raster data subsets.\n\n:::{style=\"text-align:justify\"}\n\nTo extract value for a specified location `raster::cellFromXY()` function can be used.\n\nTo subset based on extent, the bounding box details can be used.\n\nTo subset based on extent of a polygon/ other available vector dataset\n\n:::\n\n## Extract raster values for a given location.\n\n:::{style=\"text-align:justify\"}\n\nTo extract values for a given location, there are multiple methods. The `raster::extract()` function is computationally demanding and takes a lot of time, especially for extracting raster data for a large number of polygons. An alternative from terra package as well as veloxraster appears promising but needs further deliberations.\n\n:::\n\n### Map algebra.\n\n:::{style=\"text-align:justify\"}\n\nUnderstanding of map algebra makes raster processing faster. There are four subclasses of raster based operations as under:-\n\n:::\n\n### 1. Local.\n\nThese operations act independently for each cell of the raster.\n\n### 2. Focal.\n\n:::{style=\"text-align:justify\"}\n\nAlso known a kernel, moving window or filter operations for raster data, they choose a central cell and its neighbourhood (such as surrounding eight cells, for example). The focal operation acts similar to spatial data aggregation and results in an output of aggregated values for each combination of central cell and its neighbourhood. `raster::focal()` function can be used for obtaining focal values by defining the matrix for central cell and its neighbourhood.\n\n:::\n\n### 3. Zonal.\n\n:::{style=\"text-align:justify\"}\n\nThe principle behind zonal operations is same as that of focal operations. However, unlike in focal operations, zonal operations can go beyond a rectangular matrix of neighbourhood and can provide aggregated values for a pre-defined shape or distance or area, etc. The `raster::zonal()` function provides zonal statistics.\n\n:::\n\n### Global.\n\n:::{style=\"text-align:justify\"}\n\nThese operations are applied on the entire dataset and are used to summarise the characteristics of the given raster data such as mean, median, IQR, range etc of the datasets.\n\n:::\n\n## Merging rasters.\n\n:::{style=\"text-align:justify\"}\n\nTwo rasters can be merged using `raster::merge()` function in general. However, depending upon the raster characteristics, more refined methods are available such as from packages landsat, satellite, etc. Merging rasters require same resolution and crs of the rasters as prerequisites.\n\n:::",
    "supporting": [
      "spatial_data_mani_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}